## 동적계획법

동적계획법은 메모리 공간을 이용해 빠르게 문제를 해결하는 방법이다.
다음과 같은 조건을 가질 때, 사용할 수 있다.

1. 큰문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

### 피보나치 수열

피보나치 수열은 f(n)=f(n-1)+f(n-2),f(1)=f(2)=1로 표현될 수 있다.
이를 이용해 다음과 같은 코드를 작성할 수 있다.

```python
def fibo(x):
  if x==1 or x==2:
    return 1
  return fibo(x-1)+fibo(x-2)

print(fibo(3))
```

위의 방식으로만 계산할 경우, n이 커질수록 같은 계산을 반복하면서 O(2^N)의 시간복잡도를 가지게 된다.
이를 해결위한 2가지 방법을 소개하려한다.

#### 1. 탑다운 방식

탑다운 방식은 큰문제를 풀기 위해 작은 문제를 호출하는 방식으로, "메모이제이션" (캐싱)을 이용해 계산결과를 저장해 다음 결과에 사용한다.
재귀함수를 사용해 계속해서 큰수에서 작은수로 작아져간다.

```python
d=[0]*100 #이전계산을 기록해

def fibo(x):
  if x==1 or x==2:
    return 1
  if d[x]!=0:
    return d[x]
  d[x]=fibo(x-1)+fibo(x-2)
  return d[x]

print(fibo(99))
```

이전에 이미 계산해둔 값을 불러오기만 하고 새롭게 구하는 값은 N이므로 O(N)의 시간복잡도로 빠르게 구할 수 있다.

#### 2. 바텀업 방식

바텀업 방식은 아래에서 위로 올라가는 방식으로, 반복문과 DP 테이블 (저장용 리스트)를 이용해 구현할 수 있다.

```python
d[1]=1
d[2]=1
n=99

for i in range(3,n+1):
  d[i]=d[i-1]+d[i-2]

print(d[n])

```

두가지 방식 중 바텀업 방식을 이용해 계산하고 완전탐색으로 처리할 수 없을 때, 적용해서 풀어보자.
실제로 어떤 부분을 어떻게 쪼갤건지가 문제의 핵심임을 많이 느낄 수 있었다.
처음 배운 유형이라 걱정한만큼 아직 막막하지만 계속해서 반복되는 부분들이 조금씩 눈에 보인다.
기죽지 말고 계속 공부하자
